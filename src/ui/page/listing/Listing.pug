script.
	import api from '../../../api/index.js'
	import { StringMatch } from '../../../lib/index.js'
	import Button from '../../framework/Button.pug'
	import ListingNameTag from './ListingNameTag.pug'
	import ListingPost from './ListingPost.pug'
	import ListingSearchField from './ListingSearchField.pug'
	import ListingSort from './ListingSort.pug'
	import ListingTimeRange from './ListingTimeRange.pug'
	export data = null
	export type = null

	{ collection_short_id, multireddit_name, page_size, post_short_id, posts_sort, search_text, subreddits_filter, subreddit_name, user_name, wiki_name, wiki_revision_id } = data
	if !page_size then page_size = 10
	if !posts_sort then posts_sort = 'hot'

	base_page_id = null
	error = false
	filter_text = ''
	has_next_page = false
	loading = false
	page = null
	pages = []
	pages_error = []
	pages_loading = []
	
	switch type
		when 'collection_posts'
			display_name = collection_short_id
			base_path = "/c/#{collection_short_id}"
			official_path = "/collection/#{collection_short_id}"
			collection = null
			api.loadWatch(api.ID('collection', collection_short_id), ({ data: collection, error, loading }) ->
				if loading then pages_loading[0] = loading
				if error then pages_error[0] = error
				if collection
					display_name = collection.title
					pages[0] = collection.posts
			)
		when 'multireddit_posts'
			display_name = "#{user_name}/#{multireddit_name}"
			base_path = "/m/#{user_name}/#{multireddit_name}"
			official_path = "/user/#{user_name}/m/#{multireddit_name}"
			sort_options = ['new', 'rising', 'hot', 'controversial', 'top', 'search']
			if posts_sort.split('-')[0] is 'search'
				if search_text
					if user_name is 'r'
						base_page_id = api.ID('search_posts', posts_sort.split('-')[1], search_text, page_size)
					else
						base_page_id = api.ID('search_posts_in_multireddit', user_name, multireddit_name, posts_sort.split('-')[1], search_text, page_size)
			else base_page_id = api.ID('multireddit_posts', user_name, multireddit_name, posts_sort, page_size)
		when 'subreddit_posts'
			display_name = subreddit_name
			base_path = "/r/#{subreddit_name}"
			official_path = "/r/#{subreddit_name}"
			sort_options = ['new', 'rising', 'hot', 'controversial', 'top', 'search']
			if posts_sort.split('-')[0] is 'search'
				if search_text
					base_page_id = api.ID('search_posts_in_subreddit', subreddit_name, posts_sort.split('-')[1], search_text, page_size)
			else base_page_id = api.ID('subreddit_posts', subreddit_name, posts_sort, page_size)
		when 'subreddits'
			switch subreddits_filter
				when 'approved-user'
					base_page_id = api.ID('current_user_subreddits_approved_to_submit', 100)
					cache_key = 'cache.subreddits.approved'
				when 'global-new'
					base_page_id = api.ID('global_subreddits_new', 100)
					cache_key = 'cache.subreddits.global_new'
				when 'global-popular'
					base_page_id = api.ID('global_subreddits_popular', 100)
					cache_key = 'cache.subreddits.global_popular'
				when 'moderator'
					base_page_id = api.ID('current_user_subreddits_moderated', 100)
					cache_key = 'cache.subreddits.moderated'
				when 'subscriber'
					base_page_id = api.ID('current_user_subreddits_subscribed', 100)
					cache_key = 'cache.subreddits.subscribed'
			filterable = true
		when 'user_posts'
			display_name = user_name
			base_path = "/u/#{user_name}"
			official_path = "/u/#{user_name}"
			sort_options = ['new', 'hot', 'controversial', 'top']
			base_page_id = api.ID('user_posts', user_name, posts_sort, page_size)

	load_page = (page_number) ->
		if cache_key
			pages[page_number] = localStorage[cache_key + '.' + page_number]?.split(' ') ? []
		if page_number is 0
			page_id = base_page_id
		else
			after_short_id = pages[page_number - 1].at(-1)
			page_id = api.ID(base_page_id, after_short_id)
		api.loadWatch(page_id, ({ data: page, error, loading }) ->
			if loading then pages_loading[page_number] = loading
			if error then pages_error[page_number] = error
			if page
				pages[page_number] = page
				is_last_page = page_number == pages.length - 1
				if is_last_page
					if page_number is 0
						if page.length >= page_size
							has_next_page = true
					else
						if page.length < page_size
							has_next_page = false
				if cache_key
					localStorage[cache_key + '.' + page_number] = page.join(' ')
		)

	if base_page_id then load_page(0)

svelte:head
	title {base_path}
nav.listing
	{#if error}
		{#if error instanceof api.errors.ServerError}
			p Content unavailable.
			a(href='https://www.reddit.com{official_path}') Visit Reddit to see why.
	{:else if loading}
		p Loading...
	{:else}
		header.listing-info
			h1
				{#if type === 'multireddit_posts' || type === 'subreddit_posts'}
					| Posts in
				{:else if type === 'user_posts'}
					| Posts by
				{#if display_name}
					ListingNameTag(link={base_path} text={display_name} type={type})
			{#if sort_options}
				menu
					ListingSort(base_path={base_path} selection={posts_sort.split('-')[0]} sort_options={sort_options})
					{#if ['top', 'controversial', 'search'].includes(posts_sort.split('-')[0])}
						ListingTimeRange(base_path={base_path + '/' + posts_sort.split('-')[0]} selection={posts_sort.split('-')[1]})
					{#if posts_sort.split('-')[0] === 'search'}
						ListingSearchField(base_path={base_path + '/' + posts_sort} initial_query={search_text})
			{#if filterable}
				<!-- svelte-ignore a11y-autofocus -->
				input.listing-filter(autofocus={true} bind:value={filter_text} type='search')
		hr
		ol.listing-content
			{#if pages.length}
				{#each pages as page}
					{#each StringMatch.match(page, filter_text) as { string }, i}
						{#if type.endsWith('multireddits')}
							ListingNameTag(link="/m/{string.replace('-', '/')}" text={string} type='multireddit_posts')
						{:else if type.endsWith('posts')}
							ListingPost(short_id={string})
						{:else if type.endsWith('subreddits')}
							{#if string.startsWith('u_')}
								ListingNameTag(link='/u/{string.slice(2)}' text={string.slice(2)} type='user_posts')
							{:else}
								ListingNameTag(link='/r/{string}' text={string} type='subreddit_posts')
				{#if has_next_page}
					Button(action={() => load_page(pages.length)} text='More')
style.
	.listing
		width 480px
	.listing-content
		display flex
		flex-flow column nowrap
		gap 1ch
	.listing-filter
		border 1px solid
	.listing-info
		padding 10px
		position sticky
		top 0
		h1
			font inherit
		menu
			margin-top 1em